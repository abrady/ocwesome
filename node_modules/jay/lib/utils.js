var path = require('path'),
    extname = path.extname,
    dirname = path.dirname,
    join = path.join;

exports.bind = function __bind(fn, me) {
  return function() { return fn.apply(me, arguments); };
};

var escapeJSON = exports.escapeJSON = function(json) {
  var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      meta = { // table of character substitutions
              '\b': '\\b',
              '\t': '\\t',
              '\n': '\\n',
              '\f': '\\f',
              '\r': '\\r',
              '"' : '\\"',
              '\\': '\\\\'
            };

  escapable.lastIndex = 0;
  return escapable.test(json) ? '"' + json.replace(escapable, function (a) {
      var c = meta[a];
      return (typeof c === 'string') ? c
        : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
  }) + '"' : '"' + json + '"';

};

/**
 * Resolve the file path
 *
 * @param  {string} req
 * @param  {string} src
 * @api private
 * @return {str}
 */

var resolve = exports.resolve = function(req, root, src) {
  req = (!extname(req)) ? req + '.js' : req;

  if(req[0] === '/' || !src) {
    return join(root, req);
  } else if(/^\.\//.test(req) || /^\.{2}/.test(req)) {
    return join(dirname(src), req);
  } else {
    return '';
    // return join(paths.node_modules, req);
  }
};

/**
 * Relativize the js/css keys before wrapping
 * @param  {object} obj
 * @api private
 * @return {object}
 */

var relativize = exports.relativize = function(obj, root) {

  Object.keys(obj).forEach(function(key) {
    obj[key.replace(root, '')] = obj[key];
    delete obj[key];
  });

  return obj;
};

/*
  Step - tiny, but flexible step library
  
  Usage:
  
    var first = function(next) {
      ...
      return next(null, name, date);
    }
  
    var second = function(err, name, date, next) {
      ...
      return next(null, person);
    }
  
    var last = function(err, person) {
      ...
    }
    
    step(first, second, last);
*/

var step = exports.step = function() {
  var slice = Array.prototype.slice,
      stack = slice.call(arguments).reverse(),
      self  = this;
      
  function next(err) {
    // Jump to last func if error occurs
    if(err) return stack[0].call(self, err);
    
    // Otherwise gather arguments and add next func to end
    var args = slice.call(arguments);
    
    if(stack.length > 1) args.push(next);
    
    // Call the next function on the stack with given args
    stack.pop().apply(self, args);
  }
  
  // Kick us off
  stack.pop().call(self, next);
};
