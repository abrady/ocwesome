/**
 * Module dependencies
 */

var fs = require('fs'),
    path = require('path'),
    join = path.join,
    extname = path.extname,
    basename = path.basename,
    mkdirp = require('mkdirp'),
    utils = require('./utils'),
    relativize = utils.relativize,
    resolve = utils.resolve,
    step = utils.step,
    Batch = require('batch'),
    compilers = require('./compilers'),
    wrapper = require('./wrap'),
    detective = require('detective'),
    deputy = require('deputy2');

/**
 * Private API
 */

/**
 * Initialize a `jay` instance
 * @param {function} engine
 * @api private
 */

var init = exports.init = function(engine) {

  // Slide through if we're in production
  if(process.env.NODE_ENV === 'production') return engine;

  if(!this._root) throw new Error('jay requires a root to be specified');

  // Home directory
  var home = process.env.HOME || process.env.USERPROFILE;

  // Directory setup
  this._build = this._build || join(this._root, 'build');
  this._cache = this._cache || '.jay/cache.json';

  // Set up deputy unless we turn off caching
  this.detective = (this._cache !== false)
                    ? deputy(join(home, this._cache))
                    : detective;

  // Set up the js and css objects
  this.js = {};
  this.css = {};

  // Render engine
  this.engine = engine || function() {};

  // Set up the includes
  this.includes = this.includes || [];

  // Bind `out` to `this`
  return out.bind(this);
};

/**
 * Output the results
 * @param  {function} fn
 * @api private
 */

var out = exports.out = function(path, locals, fn) {
  locals = locals || {};
  fn = fn || function() {};
  if(typeof locals === 'function') {
    fn = locals;
    locals = {};
  }

  var self = this,
      batch = new Batch(),
      main = this.main = path.replace(extname(path), '.js'),
      root = this._root;

  // var start = (new Date()).getTime();
  
  // bind the functions
  var walk = this.walk.bind(this),
      wrap = this.wrap.bind(this),
      mkdir = this.mkdir.bind(this),
      write = this.write.bind(this);

  // Resolve includes
  var includes = this.includes.map(function(include) {
    return resolve(include, root);
  }, this);

  [main].concat(includes).forEach(function(include) {
    batch.push(function(done) {
      walk(include, done);
    });
  });

  batch.end(function(err) {
    if(err) return fn(err);

    step(wrap, mkdir, write, function(err) {
      if(err) return fn(err);

      // console.log(((new Date()).getTime() - start) + ' ms');
      return self.engine(path, locals, fn);
    });
  });


};

/**
 * Walk up and down the javascript requires
 * @param  {string}   src
 * @param  {function} done
 * @api private
 */

var walk = exports.walk = function(src, fn) {
  var self = this,
      aliases = this.aliases || {},
      detective = this.detective;

  src = src || this.main;

  // Read in the source and add it
  fs.readFile(src, 'utf8', function(err, str) {
    if(err) return fn(err);
    var compiler = compilers[extname(src).substring(1)];

    // Add it
    self.js[src] = (compiler) ? compiler.call(self, str, src) : str;
    if(!self.js[src]) delete self.js[src];

    var reqs = detective(str),
        pending = reqs.length;

    if(!pending) return fn(null);

    reqs.forEach(function(req) {
      req = (aliases[req]) ? aliases[req] : req;

      // Resolve the pathname
      req = resolve(req, self._root, src);

      // If we already have it, fuggetuhboutit
      if(!req || self.js[req]) return next();

      // Build it
      walk.call(self, req, next);
    });

    function next(err) {
      if(err) return fn(err);
      if(!--pending) return fn(null);
    }

  });
};

/**
 * Wrap our objects in `require`
 * @param  {error|string} err
 * @api private
 */

var wrap = exports.wrap = function(fn) {
  var root = this._root,
      main = this.main,
      js = relativize(this.js, root),
      css = relativize(this.css, root);

  js = wrapper.js(js, this.aliases);
  if(main) js += '\nrequire("' + main.replace(root, '') + '");\n';
  css = wrapper.css(css);

  return fn(null, js, css);
};

/**
 * Make the output directory before writing
 * @param  {error|string}   err
 * @param  {string}   js
 * @param  {string}   css
 * @param  {function} fn
 * @api private
 */

var mkdir = exports.mkdir = function(err, js, css, fn) {
  var main = this.main,
      base = basename(main, extname(main)),
      build = join(this._build, base);

  mkdirp(build, function(err) {
    if(err) return fn(err);
    return fn(null, js, css);
  });
};

/**
 * Write the javascript and css to the build directory
 * @param  {error}   err
 * @param  {function} fn
 * @api private
 */

var write = exports.write = function(err, js, css, fn) {
  var main = this.main,
      base = basename(main, extname(main)),
      build = join(this._build, base),
      pending = 2;

  var js_stream = fs.createWriteStream(join(build, 'jay.js')),
      css_stream = fs.createWriteStream(join(build, 'jay.css'));

  js_stream.write(js);
  css_stream.write(css);

  js_stream.end(done);
  css_stream.end(done);

  function done(err) {
    if(err) return fn(err);
    else if(!--pending) return fn(null);
  }
};

/**
 * Export the version
 */

exports.version = require('../package.json').version;

/**
 * Public API
 */

/**
 * Create a `jay` instance
 * @api public
 * @returns {object} jay
 */

var create = exports.create = function() {
  var jay = function() { return init.apply(jay, arguments); };
  
  // Inherit from `exports`
  jay.__proto__ = exports;

  return jay;
};

/**
 * Include additional modules
 * @param  {string} alias
 * @param {string} path
 * @api public
 * @return {object} jay
 */

var include = exports.include = function(alias, path) {
  if(!alias) return this;
  if(!this.includes) this.includes = [];

  // Set up alias if alias & path are specified
  if(path) {
    if(!this.aliases) this.aliases = {};
    this.aliases[alias] = path;
  } else {
    path = alias;
  }

  this.includes.push(path);
  return this;
};

/**
 * Alias a module
 * @param  {string} to
 * @param  {string} from
 * @api public
 * @return {object} jay
 */

var alias = exports.alias = function(to, from) {
  if(!to || !from) return this;
  if(!this.aliases) this.aliases = {};
  this.aliases[to] = from;
  return this;
};

/**
 * Set the root directory
 * @param  {string} root
 * @api public
 * @return {object} jay
 */

var root = exports.root = function(root) {
  this._root = root;
  return this;
};

/**
 * Set the build directory
 * @param  {string} build
 * @api public
 * @return {object} jay
 */

var build = exports.build = function(build) {
  this._build = build;
  return this;
};

/**
 * Set the cache directory, or no cache if false
 * @param  {string|boolean} cache
 * @api public
 * @return {object} jay
 */

var cache = exports.cache = function(cache) {
  this._cache = cache;
  return this;
};

/**
 * Export an instance of `jay`
 */

module.exports = create();

